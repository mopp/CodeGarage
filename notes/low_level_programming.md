# Q1
- CF, AF, ZF, OF, SFのそれぞれの意味
    + CF
        * Carry flag
        * 最上位ビットのキャリーかボローがあったときにセットされる
        * 符号なし整数演算のオーバーフローを示す
        * 任意精度演算でも使用される
    + AF
        * Auxiliary Carry flag
        * 算術演算の結果のキャリーか、3ビット目からのボローがあったときにセットされる
        * BCD演算で使用される
    + ZF
        * Zero flag
        * 結果がゼロのときにセットされる
    + OF
        * Overflow flag
        * 整数の結果が極端に大きな正の数か極端に小さな負の数 (符号ビットを含まない)
        * 2の補数の符号付き計算のオーバーフローを示す
    + SF
        * Sign flag
        * 結果の最上位ビットと同じになる
        * 0なら正の数、1なら負の数
- OFとCFの違い
    + CFはキャリーかボローが起きたかを示す
    + OFは符号ビットを示す


# Q2
- フォン・ノイマン・アーキテクチャの主な原則は？
    + メモリから読み込んだプログラムをCPUで実行する
    + データとコードの区別はない


# Q3
- レジスタとは
    + プロセッサが持つメモリセル
    + メモリより高速だが高価


# Q4
- ハードウェアスタックとは
    + pushとpop命令によってメモリ上で実現するスタックデータ構造

# Q5
- 割り込みとは
    + プログラムに外部からイベントを発行して処理を停止させ、別な処理を行えるようにする機能


# Q6
- フォン・ノイマンモデルの主な問題点で現在の拡張で解決しているのは？
    + メモリとCPUの速度差
    + 対話性の欠如
    + ハードウェアスタックによる複数の手続きの隔離
    + マルチタスク

# Q7
- Intel 64の主な汎用レジスタは？
    + r00~r15

# Q8
- スタックポインタの目的は？
    + スタックのトップを指し示す


# Q9
- スタックは空になるか？
    + SPがスタック領域の底を示すときなる


# Q10
- スタック内の要素を数えられるか
    + 数えられない
    + スタックに入れられる要素が固定長ではないため
    + バイト数であれば計算可能
