# Chapter 1
## Q1
- CF, AF, ZF, OF, SFのそれぞれの意味
    + CF
        * Carry flag
        * 最上位ビットのキャリーかボローがあったときにセットされる
        * 符号なし整数演算のオーバーフローを示す
        * 任意精度演算でも使用される
    + AF
        * Auxiliary Carry flag
        * 算術演算の結果のキャリーか、3ビット目からのボローがあったときにセットされる
        * BCD演算で使用される
    + ZF
        * Zero flag
        * 結果がゼロのときにセットされる
    + OF
        * Overflow flag
        * 整数の結果が極端に大きな正の数か極端に小さな負の数 (符号ビットを含まない)
        * 2の補数の符号付き計算のオーバーフローを示す
    + SF
        * Sign flag
        * 結果の最上位ビットと同じになる
        * 0なら正の数、1なら負の数
- OFとCFの違い
    + CFはキャリーかボローが起きたかを示す
    + OFは符号ビットを示す


## Q2
- フォン・ノイマン・アーキテクチャの主な原則は？
    + メモリから読み込んだプログラムをCPUで実行する
    + データとコードの区別はない


## Q3
- レジスタとは
    + プロセッサが持つメモリセル
    + メモリより高速だが高価


## Q4
- ハードウェアスタックとは
    + pushとpop命令によってメモリ上で実現するスタックデータ構造

## Q5
- 割り込みとは
    + プログラムに外部からイベントを発行して処理を停止させ、別な処理を行えるようにする機能


## Q6
- フォン・ノイマンモデルの主な問題点で現在の拡張で解決しているのは？
    + メモリとCPUの速度差
    + 対話性の欠如
    + ハードウェアスタックによる複数の手続きの隔離
    + マルチタスク

## Q7
- Intel 64の主な汎用レジスタは？
    + r00~r15

## Q8
- スタックポインタの目的は？
    + スタックのトップを指し示す


## Q9
- スタックは空になるか？
    + SPがスタック領域の底を示すときなる


## Q10
- スタック内の要素を数えられるか
    + 数えられない
    + スタックに入れられる要素が固定長ではないため
    + バイト数であれば計算可能

# Chapter 2
## Q11
- `xor rdi rdi`とは何をする命令か
    + rdiにrdiとrdiをxorした値を書き込む
    + rdiを0で初期化することになる

## Q12
- このプログラムのリターンコードは？
    + rdiの値なので0

## Q13
- exitシステムコールの第一引数は？
    + status code

## Q14
- サンプルのASCIIコードが正しいことを確認する
    + 実行結果が期待通りなので正しい

## Q15
- sarとshrの違いは？
    + shrは最上位ビットをクリアする
    + sarはdestinationオペランドの符号ビットを最上位ビットに設定する

## Q16
- 数を、10進数以外の方法でnasmで書くには
    + nasmのドキュメントの[3.4.1 Numeric Constants](https://www.nasm.us/doc/nasmdoc3.html#section-3.4.1)を参照
    + 2, 8, 10, 16進数で記述可能

## Q17
- jeとjzの違いは？
    + je - Jump short if equal (ZF=1).
    + jz - Jump short if zero (ZF = 1).
    + 両者ともオペコードが74 cbなので同じ命令
    + 違いを上げるとしたらコード上の意味
        * je -> 2つが同じ
        * jz -> ZF == 1
        * cmp rax, rbxの次ならjeのほうが読みやすいはず
        * sub rcx, 1の次ならjzのほうが読みやすいはず

## Q18
- 実行した結果のtestの値
    + 初期値は0xFFFF FFFF FFFF FFFF
    + `byte[test], 1` -> 0x01FF FFFF FFFF FFFF
    + `word[test], 1` -> 0x0100 FFFF FFFF FFFF
    + `dword[test], 1` -> 0x0100 0000 FFFF FFFF
    + `qword[test], 1` -> 0x0100 0000 0000 0000

## Q19
- バグを示せ
    + カウンタ用のレジスタ(r13)を0クリアしていない
    + また、r13の保存と復元もしていない

## Q20
- print_newlineをprint_charを呼び出さないようにする
    + assignment1へ

## Q21
- print_intをprint_uintを呼び出さないようにする (コードのコピーなし)
    + assignment1へ

## Q22
- print_intをprint_uintを呼び出さないようにする (コードのコピーなし、jmpもなし)
    + 1命令と配置でできるらしい
    + 謎

## Q23
- rax, eax, ax, ah, alの関係
    + 64bit, lower 32bit, lower 16bit, upper 8bit, lower 8bit
    + raxの一部部分

## Q24
- r9レジスタの一部にアクセスするにはどうすればいいか
    + r9d, r9w, r9b

## Q25
- ハードウェアスタックの使い方は？利用できる命令は？
    + push, pop
    + 現在の実行コンテキストの保持
    + ローカル変数の実現
    + 答え合わせ
        * call, ret, push, pop

## Q26
- 正しくない命令は？
    + mov [rax], 0
        * 長さが不明
    + mov r9w, r2d
        * サイズが違う
    + mov rcx, [rax + rbx + rdx]
        * 非対応
    + mov [r8 + r7 + 10], 6
        * 長さが不明
    + 答え合わせ
        * mov r3b, al                 ; NASM does not support r0-r7 names, only r8-r15 
        * mov [r8+r7+10], r6          ; NASM does not support r6 or r7 

## Q27
- 呼び出し先退避レジスタ
    + rbx, rbp, rsp, r12 - r15

## Q28
- 呼び出し元退避レジスタ
    + rbx, rbp, rsp, r12 - r15以外

## Q29
- ripレジスタの意味は？
    + 次に実行される命令

## Q30
- SFは何のフラグか
    + sign flag
    + 計算結果が負のときにセットされる

## Q31
- ZFは何のフラグか
    + zero flag
    + 計算結果が0のときにセットされる

## Q32 (FIXME)
- 命令の効果を述べよ
    + sar
        + 算術右シフト
        + 符号付きでシフトする
    + shr
        + 論理右シフト
        + 0埋めでシフトする
    + xor
        * 排他的論理和
    + jmp
        * 指定アドレスへのジャンプ
    + ja, jb, etc
        * 条件付きジャンプ
    + cmp
        * 2つのオペランドの比較
    + mov
        * 値の移動
    + inc, dec
        * 1加算か、減算
    + add
        * 加算
    + imul, mul
        * 符号付き乗算、符号なし乗算
    + sub
        * 減算
    + idiv, div
        * 符号付き除算、符号なし除算
    + call, ret
        * 関数呼出し、関数から戻る
    + push, pop
        * ハードウェアスタックの操作


## Q33
- ラベルとはなにか？サイズはあるのか
    + メモリアドレスに名前をつけるためのもの、サイズはない


## Q34
- ある数値が、ある範囲(x, y)に含まれるかどうかのチェック
    + cmp rax, x
    + jl .not_include
    + cmp rax, y
    + jg .not_include
    + include
    + .not_include:


## Q35
- ja/jbとjg/jlの違いは
    + unsignedかsigned
    + 答え合わせ
        * jl/jg are used to perform jumps after signed comparison.
        * ja/jb are used to perform jumps after unsigned comparison:


## Q36
- jeとjzの違いは
    + オペコードは同じ
    + 意味が違う


## Q37
- raxがゼロかどうかをcmpを使わずにテストする
    + test rax, rax


## Q38
- プログラムのリターンコードとはなにか
    + 終了理由や終了状態を示すもの


## Q39
- ただ一つの命令でraxを9倍にする方法は？
    + imul rax, rax, 9
    + lea rax, [rax + rax*8]


## Q40
- 2つの命令でraxの整数の絶対値を求めよ
    + .label:
    + neg rax
    + jl .label

## Q41
- リトルエンディアンとビッグエンディアンの違い
    + バイト単位の並び順が違う

## Q42
- 最も複雑な種類のアドレッシングは
    + 間接アドレッシング
    + 答え合わせ
        * base + scale * offset + displacement
        * displacement should be an immediate value, scale should be equal to 1, 2, 4 or 8.


## Q43
- プログラムの実行はどこから始まる？
    + \_start
    + or OS


## Q44 (FIXME)
- 0x11223344556778をpushしたときの[rsp + 3]の値は
    + 0x55


## Q45
- 0x08という値を持つセグメントセレクタの意味は？
    + 1番目のセグメントディスクリプタを示す
    + 答え合わせ
        * T = 0, GDTを指す
        * ring = 0, 


## Q46
- マイクロコードと、プロセッサのパイプラインについて
    + マイクロコード
        * プロセッサの実装形式の一つ
        * マイクロプログラム方式や、その方式で書かれたプログラムを指す。
    + パイプライン
        * 命令を処理するいくつかの機構を段に分けて、効率よく命令を実行する手法
    + 答え合わせ
        * マイクロコードはアセンブラよりも下位レベルのプログラムコード、複雑な命令のロジックをエンコードするのに使用される
        * パイプラインは複数のマイクロコードを同時に実行できる、性能向上に大きく寄与する


## Q47
- 様々なページ置換法について学ぶ
    + 答え合わせ
    + https://en.wikipedia.org/wiki/Cache_replacement_policies


## Q48
- 4, 5番目のcolumnの意味
    + デバイス(major:minor)とその上のinodeの番号


## Q49 (FIXME)
- アソシエイティブキャッシュとはなにか、なぜTLBがそう呼ばれるのか
    + メインメモリのアドレスに一定の計算を行ってキャッシュメモリ上の格納位置を算出し、その位置にあるいくつかのブロックのいずれかにデータを格納する方式。
    + TLBではセットアソシアティブ方式を使用するから
- https://web.archive.org/web/20170508141002/https://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Memory/fully.html


## Q50
- 仮想メモリのregionとは
    + 以下の2つを満たすもの
    + ページサイズの倍数であるアドレスから始まる
    + すべてのページが同じパーミッションを持つ


# Q51
- プログラムの実行コードを、その実行中に書き換えようとしたらどうなる
    + segmentation failtでエラーになる


# Q52
- 無効なアドレスとは
    + ページの存在しないアドレス
    + 答え合わせ
        * 現在のプロセスのページテーブルに存在しないページのアドレス


# Q53
- 正規アドレスとは
    + 48から63ビット目が47ビット目と同じになっているアドレス


# Q54
- 変換テーブルとは
    + 仮想アドレスを物理アドレスに変換するための情報が格納されたデータ構造


# Q55
- ページフレームとは
    + ページと同じサイズを持つ物理メモリの領域
    + 答え合わせ
        * ページと同じアラインメントを持つ


# Q56
- メモリの領域とは
    + メモリの連続した塊を指す
    + 答え合わせ
        * ページサイズの倍数となるアドレスから始まる
        * 同じパーミッションを持つ


# Q57
- 仮想アドレス空間とはなにか、物理アドレス空間との違いは？
    + 仮想アドレス空間はページテーブルによって構築されるもの、プロセスごとに異なる
    + 物理アドレス空間は実際に搭載されたメモリの空間
    + 答え合わせ
        * 物理アドレス空間はユニーク、仮想メモリ空間はプロセスごとに作られる
        * 仮想メモリ空間は物理メモリ空間にマップされる


# Q58
- TLBとはなにか
    + translation lookaside buffer.
    + 仮想メモリのためのキャッシュ機構
    + 答え合わせ
        * 直近にアクセスのあった仮想メモリに対応する物理メモリアドレスをキャッシュする
        * これによる、変換メカニズムが頻繁に実行されるのを避けられる


# Q59
- 仮想メモリ機構が十分に高速なのは何のおかげか？
    + 局所性とTLBのおかげ


# Q60
- アドレス空間はどうやって切り替えるのか
    + cr3レジスタの切り替え


# Q61
- 仮想メモリに組み込まれているプロテクション機構とは？
    + read, write, executionを有効無効に設定できる
    + 答え合わせ
        * U bit, ring protection


# Q62
- EXBビットの目的は？
    + コード実行を禁止するためのフラグ


# Q63
- 仮想アドレスの構造は？
    + 4段構造、テーブルとそこに格納されるエントリからなる


# Q64
- 仮想アドレスと物理アドレスで共通する部分はあるのか？
    + 1バイト単位のアドレッシングであること
    + 答え合わせ
        * 下位12ビットのオフセットが共通する


# Q65
- .textセクションに文字列を書けるか、それを読んだならどうなるか、上書きしたらどうなるか
    + コンパイル時であれば書き込める
    + それを読み出しは可能
    + 実行時に上書きは通常EXBビットで保護されるために不可能
    + 答え合わせ
        * 書き込み保護はEXBではなくWビットで実現する


# Q66 (FIXME)
- システムコールのstat, open, mmapを呼び出すプログラムを書く
    + 066.nas


# Q67 (FIXME)
- いろいろ
    + 067.nas


# Q68
- `%define`と`%macro`の例を探す
    + [NASM - The Netwide Assembler](https://www.nasm.us/doc/nasmdoc4.html)


# Q69
- `defining_in_cla.asm`のプリプロセスの結果を見る
    ```zsh
        % nasm -E defining_in_cla.asm 

        % nasm -E defining_in_cla.asm -Dflag
            %line 2+1 defining_in_cla.asm
            hellostring: db "Hello",0
    ```


# Q70 (FIXME)
- 070.nas


# Q71 (FIXME)
- ldが警告を出すのはなぜか
    + エントリポイントのアドレスがglobalの有無にかかわらず、`readelf -e`で見ると0x4000b0だった
        + global無し
        > 8: 00000000004000b0     0 NOTYPE  LOCAL  DEFAULT    1 _start
        + global有り
        > 8: 00000000004000b4     0 NOTYPE  LOCAL  DEFAULT    1 _start.loop


# Q72
- ldにシンボルテーブルを自動でstripするオプションはあるか
    > -s, --strip-all             Strip all symbols
    > -S, --strip-debug           Strip debugging symbols


# Q73 (FIXME)
- `readelf --dyn=syms`と`objdump -ft`でシンボルテーブルを調べる
   + `readelf --dyn=syms`
        ```
        Symbol table '.dynsym' contains 5 entries:
           Num:    Value          Size Type    Bind   Vis      Ndx Name
             0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
             1: 0000000000201018     0 NOTYPE  GLOBAL DEFAULT   10 _edata
             2: 0000000000201018     0 NOTYPE  GLOBAL DEFAULT   10 _end
             3: 0000000000201018     0 NOTYPE  GLOBAL DEFAULT   10 __bss_start
             4: 0000000000000230     0 FUNC    GLOBAL DEFAULT    6 func
        ```
   + `objdump -ft`
        ```
        ./libso.so:     file format elf64-x86-64
        architecture: i386:x86-64, flags 0x00000150:
        HAS_SYMS, DYNAMIC, D_PAGED
        start address 0x0000000000000230

        SYMBOL TABLE:
        0000000000000120 l    d  .hash	0000000000000000 .hash
        0000000000000148 l    d  .gnu.hash	0000000000000000 .gnu.hash
        0000000000000180 l    d  .dynsym	0000000000000000 .dynsym
        00000000000001f8 l    d  .dynstr	0000000000000000 .dynstr
        0000000000000218 l    d  .rela.dyn	0000000000000000 .rela.dyn
        0000000000000230 l    d  .text	0000000000000000 .text
        000000000000024c l    d  .rodata	0000000000000000 .rodata
        0000000000000268 l    d  .eh_frame	0000000000000000 .eh_frame
        0000000000200f00 l    d  .dynamic	0000000000000000 .dynamic
        0000000000201000 l    d  .got.plt	0000000000000000 .got.plt
        0000000000000000 l    df *ABS*	0000000000000000 libso.asm
        000000000000024c l       .rodata	0000000000000000 message
        0000000000000000 l    df *ABS*	0000000000000000 
        0000000000200f00 l     O .dynamic	0000000000000000 _DYNAMIC
        0000000000201000 l     O .got.plt	0000000000000000 _GLOBAL_OFFSET_TABLE_
        0000000000201018 g       .got.plt	0000000000000000 __bss_start
        0000000000000230 g     F .text	0000000000000000 func
        0000000000201018 g       .got.plt	0000000000000000 _edata
        0000000000201018 g       .got.plt	0000000000000000 _end
        ```
    + funcがグローバルになっているのがわかる

# Q74
- LD_LIBRARY_PATHの意味
    + 共有ライブラリの検索パス
- 答え合わせ
    + 優先度はデフォルトのパスより高くなる

# Q75 (FIXME)
- 入出力ライブラリを2つのモジュールに分割する
    + includeで取り込み実装するのではなく、objectでリンク可能にした
        * lib.incにglobalを追加
        * 仕様側でexternを書く

# Q76 (FIXME)
- lsを見てみる
    + `objdump -ft`
       ```
        /usr/bin/ls:     file format elf64-x86-64
        architecture: i386:x86-64, flags 0x00000150:
        HAS_SYMS, DYNAMIC, D_PAGED
        start address 0x0000000000005000

        SYMBOL TABLE:
        no symbols
       ```
        * `EXEC_P`が無いが実行できる
            - `readelf -l`で見たところelfファイルタイプはDYN(Shared object file)だった
    + `readelf -S`
        ```
        There are 25 section headers, starting at offset 0x20390:

        Section Headers:
          [Nr] Name              Type             Address           Offset
               Size              EntSize          Flags  Link  Info  Align
          [ 0]                   NULL             0000000000000000  00000000
               0000000000000000  0000000000000000           0     0     0
          [ 1] .interp           PROGBITS         0000000000000238  00000238
               000000000000001c  0000000000000000   A       0     0     1
          [ 2] .note.ABI-tag     NOTE             0000000000000254  00000254
               0000000000000020  0000000000000000   A       0     0     4
          [ 3] .note.gnu.build-i NOTE             0000000000000274  00000274
               0000000000000024  0000000000000000   A       0     0     4
          [ 4] .gnu.hash         GNU_HASH         0000000000000298  00000298
               00000000000000f4  0000000000000000   A       5     0     8
          [ 5] .dynsym           DYNSYM           0000000000000390  00000390
               0000000000000cf0  0000000000000018   A       6     1     8
          [ 6] .dynstr           STRTAB           0000000000001080  00001080
               00000000000005e8  0000000000000000   A       0     0     1
          [ 7] .gnu.version      VERSYM           0000000000001668  00001668
               0000000000000114  0000000000000002   A       5     0     2
          [ 8] .gnu.version_r    VERNEED          0000000000001780  00001780
               0000000000000070  0000000000000000   A       6     1     8
          [ 9] .rela.dyn         RELA             00000000000017f0  000017f0
               0000000000001db8  0000000000000018   A       5     0     8
          [10] .init             PROGBITS         00000000000035a8  000035a8
               0000000000000017  0000000000000000  AX       0     0     4
          [11] .text             PROGBITS         00000000000035c0  000035c0
               0000000000012839  0000000000000000  AX       0     0     16
          [12] .fini             PROGBITS         0000000000015dfc  00015dfc
               0000000000000009  0000000000000000  AX       0     0     4
          [13] .rodata           PROGBITS         0000000000015e20  00015e20
               0000000000004dec  0000000000000000   A       0     0     32
          [14] .eh_frame_hdr     PROGBITS         000000000001ac0c  0001ac0c
               000000000000084c  0000000000000000   A       0     0     4
          [15] .eh_frame         PROGBITS         000000000001b458  0001b458
               0000000000002bf8  0000000000000000   A       0     0     8
          [16] .init_array       INIT_ARRAY       000000000021f030  0001f030
               0000000000000008  0000000000000008  WA       0     0     8
          [17] .fini_array       FINI_ARRAY       000000000021f038  0001f038
               0000000000000008  0000000000000008  WA       0     0     8
          [18] .data.rel.ro      PROGBITS         000000000021f040  0001f040
               0000000000000a38  0000000000000000  WA       0     0     32
          [19] .dynamic          DYNAMIC          000000000021fa78  0001fa78
               00000000000001c0  0000000000000010  WA       6     0     8
          [20] .got              PROGBITS         000000000021fc38  0001fc38
               00000000000003c8  0000000000000008  WA       0     0     8
          [21] .data             PROGBITS         0000000000220000  00020000
               0000000000000268  0000000000000000  WA       0     0     32
          [22] .bss              NOBITS           0000000000220280  00020268
               00000000000012e0  0000000000000000  WA       0     0     32
          [23] .comment          PROGBITS         0000000000000000  00020268
               0000000000000034  0000000000000001  MS       0     0     1
          [24] .shstrtab         STRTAB           0000000000000000  0002029c
               00000000000000ed  0000000000000000           0     0     1
        Key to Flags:
          W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
          L (link order), O (extra OS processing required), G (group), T (TLS),
          C (compressed), x (unknown), o (OS specific), E (exclude),
          l (large), p (processor specific)
        ```
        * init_arrayが見慣れないので調べたが、関数アドレスのテーブルのようだった
            * コンストラクタのアドレスなどが配置され、実行時リンカ(ローダ？)によって実行されるらしい
            * [初期設定および終了ルーチン (リンカーとライブラリ)](https://docs.oracle.com/cd/E19683-01/817-3496/6mj39o7ia/index.html)
            * .fini_arrayがデストラクタに相当するはず

# Q77
- 連結リストとはなにか
    + 何らかの値と次の要素のアドレスからなるデータ構造
    + 配列のように扱えるがアドレスはランダムになり、挿入や削除が容易になる

# Q78
- コンパイルの段階には何があるか
    + 前処理とマシン語命令への変換処理
- 答え合わせ
    + プリプロセス、変換、リンク

# Q79
- 前処理とは
    + マクロの解決など

# Q80
- マクロの実体化とは
    + マクロ名から実際の値に変換すること
- 答え合わせ
    + マクロのボディが引数とともに置換されることをマクロの実体化(macro instantiation)という

# Q81
- `%define` ディレクティブとは
    + 1行のマクロの定義
- 答え合わせ
    + プリプロセッサによる置換の定義

# Q82 (FIXME: typo)
- `%macro` ディレクティブとは
    + 複数行のマクロの定義

# Q83 (FIXME)
- `%define`, `%xdefine`, `%assign`の違い
    + `%define`
        + そのマクロの展開時の値が使われる
    + `%xdefine`
        + そのマクロの定義時の値が使われる
    + `%assign`
        + 数値計算した結果が使われる

# Q84 (FIXME)
- なぜマクロの内側に%%演算子が必要なのか
    + マクロローカルなラベルを定義するため

# Q85 (FIXME)
- nasmのマクロプリプロセッサがサポートする条件に、何があるか、どのディレクティブを使うか
    + `%ifdef`, `%if`, `%ifmacro`などがある

# Q86
- ELFオブジェクトファイルの3つの種類とは
    + relocatable object file
    + executable object file
    + shared object file

# Q87
- ELFファイルにはどんなヘッダがあるのか
    + メインヘッダ
        * セクションヘッダ
        * プログラムヘッダ
- 答え合わせ
    + ファイルヘッダもある (readelf -f)

# Q88
- 再配置とは
    + プログラムの各部に決定的なアドレスを割り当て、全てのリンクが適切に解決するようにプログラムのコードを変更する処理

# Q89
- ELFファイルの中に入る可能性のあるセクションはなにか
    + text, data, rodata, bssなど

# Q90
- シンボルテーブルとはなにか、どのような情報が入るか
    + オブジェクト内に存在するシンボル一覧
    + 仮想アドレスや、属性、アラインメントなどの情報が入る

# Q91
- セクションとセグメントには関連があるだろうか
    + セクションをいくつかまとめたものがセグメント
- 答え合わせ
    + セクションは静的に生成される、対して、セグメントは動的に生成される
    + セクションはセクションヘッダに、セグメントはプログラムヘッダにそれぞれ宣言される
    + それぞれのセクションは一つ以上のセグメントのコンテナである
    + すべてのセクションがセグメントに内包されるわけではない (またすべてのセクションがロードされるわけでもない)
    + セグメントは仮想ページのパーミッションを定義する、一つのセグメント内に複数のデータセクションが置かれるとき、例えば実行不可能に設定される

# Q92
- アセンブリのセクションとELFのセクションは関連があるだろうか
    + 対応する
- 答え合わせ
    + アセンブリのセクションがELFのセクションに変換される
    + しかし、すべてのELFセクションがアセンブリから生成されるわけではない

# Q93
- プログラムのエントリポイントをマークするシンボルは
    + `_start`

# Q94
- ライブラリの2つの種類とは
    + 動的ライブラリ/静的ライブラリ

# Q95
- 静的ライブラリと、再配置可能なオブジェクトとの間に、違いはあるのか
    + ある
    + 静的ライブラリは複数の再配置可能なオブジェクトのアーカイブである
- 答え合わせ
    + 基本的には無い、とみなしていいらしい
    + 上に書いた事項のみが違う
    + じゃああるのでは
