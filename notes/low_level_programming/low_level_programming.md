# Chapter 1
## Q1
- CF, AF, ZF, OF, SFのそれぞれの意味
    + CF
        * Carry flag
        * 最上位ビットのキャリーかボローがあったときにセットされる
        * 符号なし整数演算のオーバーフローを示す
        * 任意精度演算でも使用される
    + AF
        * Auxiliary Carry flag
        * 算術演算の結果のキャリーか、3ビット目からのボローがあったときにセットされる
        * BCD演算で使用される
    + ZF
        * Zero flag
        * 結果がゼロのときにセットされる
    + OF
        * Overflow flag
        * 整数の結果が極端に大きな正の数か極端に小さな負の数 (符号ビットを含まない)
        * 2の補数の符号付き計算のオーバーフローを示す
    + SF
        * Sign flag
        * 結果の最上位ビットと同じになる
        * 0なら正の数、1なら負の数
- OFとCFの違い
    + CFはキャリーかボローが起きたかを示す
    + OFは符号ビットを示す


## Q2
- フォン・ノイマン・アーキテクチャの主な原則は？
    + メモリから読み込んだプログラムをCPUで実行する
    + データとコードの区別はない


## Q3
- レジスタとは
    + プロセッサが持つメモリセル
    + メモリより高速だが高価


## Q4
- ハードウェアスタックとは
    + pushとpop命令によってメモリ上で実現するスタックデータ構造

## Q5
- 割り込みとは
    + プログラムに外部からイベントを発行して処理を停止させ、別な処理を行えるようにする機能


## Q6
- フォン・ノイマンモデルの主な問題点で現在の拡張で解決しているのは？
    + メモリとCPUの速度差
    + 対話性の欠如
    + ハードウェアスタックによる複数の手続きの隔離
    + マルチタスク

## Q7
- Intel 64の主な汎用レジスタは？
    + r00~r15

## Q8
- スタックポインタの目的は？
    + スタックのトップを指し示す


## Q9
- スタックは空になるか？
    + SPがスタック領域の底を示すときなる


## Q10
- スタック内の要素を数えられるか
    + 数えられない
    + スタックに入れられる要素が固定長ではないため
    + バイト数であれば計算可能

# Chapter 2
## Q11
- `xor rdi rdi`とは何をする命令か
    + rdiにrdiとrdiをxorした値を書き込む
    + rdiを0で初期化することになる

## Q12
- このプログラムのリターンコードは？
    + rdiの値なので0

## Q13
- exitシステムコールの第一引数は？
    + status code

## Q14
- サンプルのASCIIコードが正しいことを確認する
    + 実行結果が期待通りなので正しい

## Q15
- sarとshrの違いは？
    + shrは最上位ビットをクリアする
    + sarはdestinationオペランドの符号ビットを最上位ビットに設定する

## Q16
- 数を、10進数以外の方法でnasmで書くには
    + nasmのドキュメントの[3.4.1 Numeric Constants](https://www.nasm.us/doc/nasmdoc3.html#section-3.4.1)を参照
    + 2, 8, 10, 16進数で記述可能

## Q17
- jeとjzの違いは？
    + je - Jump short if equal (ZF=1).
    + jz - Jump short if zero (ZF = 1).
    + 両者ともオペコードが74 cbなので同じ命令
    + 違いを上げるとしたらコード上の意味
        * je -> 2つが同じ
        * jz -> ZF == 1
        * cmp rax, rbxの次ならjeのほうが読みやすいはず
        * sub rcx, 1の次ならjzのほうが読みやすいはず

## Q18
- 実行した結果のtestの値
    + 初期値は0xFFFF FFFF FFFF FFFF
    + `byte[test], 1` -> 0x01FF FFFF FFFF FFFF
    + `word[test], 1` -> 0x0100 FFFF FFFF FFFF
    + `dword[test], 1` -> 0x0100 0000 FFFF FFFF
    + `qword[test], 1` -> 0x0100 0000 0000 0000

## Q19
- バグを示せ
    + カウンタ用のレジスタ(r13)を0クリアしていない
    + また、r13の保存と復元もしていない

