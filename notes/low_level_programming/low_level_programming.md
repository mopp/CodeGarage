# Chapter 1
## Q1
- CF, AF, ZF, OF, SFのそれぞれの意味
    + CF
        * Carry flag
        * 最上位ビットのキャリーかボローがあったときにセットされる
        * 符号なし整数演算のオーバーフローを示す
        * 任意精度演算でも使用される
    + AF
        * Auxiliary Carry flag
        * 算術演算の結果のキャリーか、3ビット目からのボローがあったときにセットされる
        * BCD演算で使用される
    + ZF
        * Zero flag
        * 結果がゼロのときにセットされる
    + OF
        * Overflow flag
        * 整数の結果が極端に大きな正の数か極端に小さな負の数 (符号ビットを含まない)
        * 2の補数の符号付き計算のオーバーフローを示す
    + SF
        * Sign flag
        * 結果の最上位ビットと同じになる
        * 0なら正の数、1なら負の数
- OFとCFの違い
    + CFはキャリーかボローが起きたかを示す
    + OFは符号ビットを示す


## Q2
- フォン・ノイマン・アーキテクチャの主な原則は？
    + メモリから読み込んだプログラムをCPUで実行する
    + データとコードの区別はない


## Q3
- レジスタとは
    + プロセッサが持つメモリセル
    + メモリより高速だが高価


## Q4
- ハードウェアスタックとは
    + pushとpop命令によってメモリ上で実現するスタックデータ構造

## Q5
- 割り込みとは
    + プログラムに外部からイベントを発行して処理を停止させ、別な処理を行えるようにする機能


## Q6
- フォン・ノイマンモデルの主な問題点で現在の拡張で解決しているのは？
    + メモリとCPUの速度差
    + 対話性の欠如
    + ハードウェアスタックによる複数の手続きの隔離
    + マルチタスク

## Q7
- Intel 64の主な汎用レジスタは？
    + r00~r15

## Q8
- スタックポインタの目的は？
    + スタックのトップを指し示す


## Q9
- スタックは空になるか？
    + SPがスタック領域の底を示すときなる


## Q10
- スタック内の要素を数えられるか
    + 数えられない
    + スタックに入れられる要素が固定長ではないため
    + バイト数であれば計算可能

# Chapter 2
## Q11
- `xor rdi rdi`とは何をする命令か
    + rdiにrdiとrdiをxorした値を書き込む
    + rdiを0で初期化することになる

## Q12
- このプログラムのリターンコードは？
    + rdiの値なので0

## Q13
- exitシステムコールの第一引数は？
    + status code

## Q14
- サンプルのASCIIコードが正しいことを確認する
    + 実行結果が期待通りなので正しい

## Q15
- sarとshrの違いは？
    + shrは最上位ビットをクリアする
    + sarはdestinationオペランドの符号ビットを最上位ビットに設定する

## Q16
- 数を、10進数以外の方法でnasmで書くには
    + nasmのドキュメントの[3.4.1 Numeric Constants](https://www.nasm.us/doc/nasmdoc3.html#section-3.4.1)を参照
    + 2, 8, 10, 16進数で記述可能

## Q17
- jeとjzの違いは？
    + je - Jump short if equal (ZF=1).
    + jz - Jump short if zero (ZF = 1).
    + 両者ともオペコードが74 cbなので同じ命令
    + 違いを上げるとしたらコード上の意味
        * je -> 2つが同じ
        * jz -> ZF == 1
        * cmp rax, rbxの次ならjeのほうが読みやすいはず
        * sub rcx, 1の次ならjzのほうが読みやすいはず

## Q18
- 実行した結果のtestの値
    + 初期値は0xFFFF FFFF FFFF FFFF
    + `byte[test], 1` -> 0x01FF FFFF FFFF FFFF
    + `word[test], 1` -> 0x0100 FFFF FFFF FFFF
    + `dword[test], 1` -> 0x0100 0000 FFFF FFFF
    + `qword[test], 1` -> 0x0100 0000 0000 0000

## Q19
- バグを示せ
    + カウンタ用のレジスタ(r13)を0クリアしていない
    + また、r13の保存と復元もしていない

## Q20
- print_newlineをprint_charを呼び出さないようにする
    + assignment1へ

## Q21
- print_intをprint_uintを呼び出さないようにする (コードのコピーなし)
    + assignment1へ

## Q22
- print_intをprint_uintを呼び出さないようにする (コードのコピーなし、jmpもなし)
    + 1命令と配置でできるらしい
    + 謎

## Q23
- rax, eax, ax, ah, alの関係
    + 64bit, lower 32bit, lower 16bit, upper 8bit, lower 8bit
    + raxの一部部分

## Q24
- r9レジスタの一部にアクセスするにはどうすればいいか
    + r9d, r9w, r9b

## Q25
- ハードウェアスタックの使い方は？利用できる命令は？
    + push, pop
    + 現在の実行コンテキストの保持
    + ローカル変数の実現

## Q26
- 正しくない命令は？
    + mov [rax], 0
        * 長さが不明
    + mov r9w, r2d
        * サイズが違う
    + mov rcx, [rax + rbx + rdx]
        * 非対応
    + mov [r8 + r7 + 10], 6
        * 長さが不明

## Q27
- 呼び出し先退避レジスタ
    + rbx, rbp, rsp, r12 - r15

## Q28
- 呼び出し元退避レジスタ
    + rbx, rbp, rsp, r12 - r15以外

## Q29
- ripレジスタの意味は？
    + 実行した命令アドレス

## Q30
- SFは何のフラグか
    + sign flag

## Q31
- ZFは何のフラグか
    + zero flag

## Q32
- 命令の効果を述べよ
    + sar
        + 算術右シフト
        + 符号付きでシフトする
    + shr
        + 論理右シフト
        + 0埋めでシフトする
    + xor
        * 排他的論理和
    + jmp
        * 指定アドレスへのジャンプ
    + ja, jb, etc
        * 条件付きジャンプ
    + cmp
        * 2つのオペランドの比較
    + mov
        * 値の移動
    + inc, dec
        * 1加算か、減算
    + add
        * 加算
    + imul, mul
        * 符号付き乗算、符号なし乗算
    + sub
        * 減算
    + idiv, div
        * 符号付き除算、符号なし除算
    + call, ret
        * 関数呼出し、関数から戻る
    + push, pop
        * ハードウェアスタックの操作


## Q33
- ラベルとはなにか？サイズはあるのか
    + メモリアドレスに名前をつけるためのもの、サイズはない


## Q34
- ある数値が、ある範囲(x, y)に含まれるかどうかのチェック
    + cmp rax, x
    + jl .not_include
    + cmp rax, y
    + jg .not_include
    + include
    + .not_include:


## Q35
- ja/jbとjg/jlの違いは
    + unsignedかsigned


## Q36
- jeとjzの違いは
    + オペコードは同じ
    + 意味が違う


## Q37
- raxがゼロかどうかをcmpを使わずにテストする
    + test rax, rax


## Q38
- プログラムのリターンコードとはなにか
    + 終了理由や終了状態を示すもの


## Q39
- ただ一つの命令でraxを9倍にする方法は？
    + imul rax, rax, 9
    + lea rax, [rax + rax*8]


## Q40
- 2つの命令でraxの整数の絶対値を求めよ
    + .label:
    + neg rax
    + jl .label

## Q41
- リトルエンディアンとビッグエンディアンの違い
    + バイト単位の並び順が違う

## Q42
- 最も複雑な種類のアドレッシングは
    + 間接アドレッシング

## Q43
- プログラムの実行はどこから始まる？
    + \_start
    + or OS

## Q44
- 0x11223344556778をpushしたときの[rsp + 3]の値は
    + 0x55
