# Chapter 1
## Q1
- CF, AF, ZF, OF, SFのそれぞれの意味
    + CF
        * Carry flag
        * 最上位ビットのキャリーかボローがあったときにセットされる
        * 符号なし整数演算のオーバーフローを示す
        * 任意精度演算でも使用される
    + AF
        * Auxiliary Carry flag
        * 算術演算の結果のキャリーか、3ビット目からのボローがあったときにセットされる
        * BCD演算で使用される
    + ZF
        * Zero flag
        * 結果がゼロのときにセットされる
    + OF
        * Overflow flag
        * 整数の結果が極端に大きな正の数か極端に小さな負の数 (符号ビットを含まない)
        * 2の補数の符号付き計算のオーバーフローを示す
    + SF
        * Sign flag
        * 結果の最上位ビットと同じになる
        * 0なら正の数、1なら負の数
- OFとCFの違い
    + CFはキャリーかボローが起きたかを示す
    + OFは符号ビットを示す


## Q2
- フォン・ノイマン・アーキテクチャの主な原則は？
    + メモリから読み込んだプログラムをCPUで実行する
    + データとコードの区別はない


## Q3
- レジスタとは
    + プロセッサが持つメモリセル
    + メモリより高速だが高価


## Q4
- ハードウェアスタックとは
    + pushとpop命令によってメモリ上で実現するスタックデータ構造

## Q5
- 割り込みとは
    + プログラムに外部からイベントを発行して処理を停止させ、別な処理を行えるようにする機能


## Q6
- フォン・ノイマンモデルの主な問題点で現在の拡張で解決しているのは？
    + メモリとCPUの速度差
    + 対話性の欠如
    + ハードウェアスタックによる複数の手続きの隔離
    + マルチタスク

## Q7
- Intel 64の主な汎用レジスタは？
    + r00~r15

## Q8
- スタックポインタの目的は？
    + スタックのトップを指し示す


## Q9
- スタックは空になるか？
    + SPがスタック領域の底を示すときなる


## Q10
- スタック内の要素を数えられるか
    + 数えられない
    + スタックに入れられる要素が固定長ではないため
    + バイト数であれば計算可能

# Chapter 2
## Q11
- `xor rdi rdi`とは何をする命令か
    + rdiにrdiとrdiをxorした値を書き込む
    + rdiを0で初期化することになる

## Q12
- このプログラムのリターンコードは？
    + rdiの値なので0

## Q13
- exitシステムコールの第一引数は？
    + status code

## Q14
- サンプルのASCIIコードが正しいことを確認する
    + 実行結果が期待通りなので正しい

## Q15
- sarとshrの違いは？
    + shrは最上位ビットをクリアする
    + sarはdestinationオペランドの符号ビットを最上位ビットに設定する

## Q16
- 数を、10進数以外の方法でnasmで書くには
    + nasmのドキュメントの[3.4.1 Numeric Constants](https://www.nasm.us/doc/nasmdoc3.html#section-3.4.1)を参照
    + 2, 8, 10, 16進数で記述可能

## Q17
- jeとjzの違いは？
    + je - Jump short if equal (ZF=1).
    + jz - Jump short if zero (ZF = 1).
    + 両者ともオペコードが74 cbなので同じ命令
    + 違いを上げるとしたらコード上の意味
        * je -> 2つが同じ
        * jz -> ZF == 1
        * cmp rax, rbxの次ならjeのほうが読みやすいはず
        * sub rcx, 1の次ならjzのほうが読みやすいはず

## Q18
- 実行した結果のtestの値
    + 初期値は0xFFFF FFFF FFFF FFFF
    + `byte[test], 1` -> 0x01FF FFFF FFFF FFFF
    + `word[test], 1` -> 0x0100 FFFF FFFF FFFF
    + `dword[test], 1` -> 0x0100 0000 FFFF FFFF
    + `qword[test], 1` -> 0x0100 0000 0000 0000

## Q19
- バグを示せ
    + カウンタ用のレジスタ(r13)を0クリアしていない
    + また、r13の保存と復元もしていない

## Q20
- print_newlineをprint_charを呼び出さないようにする
    + assignment1へ

## Q21
- print_intをprint_uintを呼び出さないようにする (コードのコピーなし)
    + assignment1へ

## Q22
- print_intをprint_uintを呼び出さないようにする (コードのコピーなし、jmpもなし)
    + 1命令と配置でできるらしい
    + 謎

## Q23
- rax, eax, ax, ah, alの関係
    + 64bit, lower 32bit, lower 16bit, upper 8bit, lower 8bit
    + raxの一部部分

## Q24
- r9レジスタの一部にアクセスするにはどうすればいいか
    + r9d, r9w, r9b

## Q25
- ハードウェアスタックの使い方は？利用できる命令は？
    + push, pop
    + 現在の実行コンテキストの保持
    + ローカル変数の実現
    + 答え合わせ
        * call, ret, push, pop

## Q26
- 正しくない命令は？
    + mov [rax], 0
        * 長さが不明
    + mov r9w, r2d
        * サイズが違う
    + mov rcx, [rax + rbx + rdx]
        * 非対応
    + mov [r8 + r7 + 10], 6
        * 長さが不明
    + 答え合わせ
        * mov r3b, al                 ; NASM does not support r0-r7 names, only r8-r15 
        * mov [r8+r7+10], r6          ; NASM does not support r6 or r7 

## Q27
- 呼び出し先退避レジスタ
    + rbx, rbp, rsp, r12 - r15

## Q28
- 呼び出し元退避レジスタ
    + rbx, rbp, rsp, r12 - r15以外

## Q29
- ripレジスタの意味は？
    + 次に実行される命令

## Q30
- SFは何のフラグか
    + sign flag
    + 計算結果が負のときにセットされる

## Q31
- ZFは何のフラグか
    + zero flag
    + 計算結果が0のときにセットされる

## Q32 (FIXME)
- 命令の効果を述べよ
    + sar
        + 算術右シフト
        + 符号付きでシフトする
    + shr
        + 論理右シフト
        + 0埋めでシフトする
    + xor
        * 排他的論理和
    + jmp
        * 指定アドレスへのジャンプ
    + ja, jb, etc
        * 条件付きジャンプ
    + cmp
        * 2つのオペランドの比較
    + mov
        * 値の移動
    + inc, dec
        * 1加算か、減算
    + add
        * 加算
    + imul, mul
        * 符号付き乗算、符号なし乗算
    + sub
        * 減算
    + idiv, div
        * 符号付き除算、符号なし除算
    + call, ret
        * 関数呼出し、関数から戻る
    + push, pop
        * ハードウェアスタックの操作


## Q33
- ラベルとはなにか？サイズはあるのか
    + メモリアドレスに名前をつけるためのもの、サイズはない


## Q34
- ある数値が、ある範囲(x, y)に含まれるかどうかのチェック
    + cmp rax, x
    + jl .not_include
    + cmp rax, y
    + jg .not_include
    + include
    + .not_include:


## Q35
- ja/jbとjg/jlの違いは
    + unsignedかsigned
    + 答え合わせ
        * jl/jg are used to perform jumps after signed comparison.
        * ja/jb are used to perform jumps after unsigned comparison:


## Q36
- jeとjzの違いは
    + オペコードは同じ
    + 意味が違う


## Q37
- raxがゼロかどうかをcmpを使わずにテストする
    + test rax, rax


## Q38
- プログラムのリターンコードとはなにか
    + 終了理由や終了状態を示すもの


## Q39
- ただ一つの命令でraxを9倍にする方法は？
    + imul rax, rax, 9
    + lea rax, [rax + rax*8]


## Q40
- 2つの命令でraxの整数の絶対値を求めよ
    + .label:
    + neg rax
    + jl .label

## Q41
- リトルエンディアンとビッグエンディアンの違い
    + バイト単位の並び順が違う

## Q42
- 最も複雑な種類のアドレッシングは
    + 間接アドレッシング
    + 答え合わせ
        * base + scale * offset + displacement
        * displacement should be an immediate value, scale should be equal to 1, 2, 4 or 8.


## Q43
- プログラムの実行はどこから始まる？
    + \_start
    + or OS


## Q44 (FIXME)
- 0x11223344556778をpushしたときの[rsp + 3]の値は
    + 0x55


## Q45
- 0x08という値を持つセグメントセレクタの意味は？
    + 1番目のセグメントディスクリプタを示す
    + 答え合わせ
        * T = 0, GDTを指す
        * ring = 0, 


## Q46
- マイクロコードと、プロセッサのパイプラインについて
    + マイクロコード
        * プロセッサの実装形式の一つ
        * マイクロプログラム方式や、その方式で書かれたプログラムを指す。
    + パイプライン
        * 命令を処理するいくつかの機構を段に分けて、効率よく命令を実行する手法
    + 答え合わせ
        * マイクロコードはアセンブラよりも下位レベルのプログラムコード、複雑な命令のロジックをエンコードするのに使用される
        * パイプラインは複数のマイクロコードを同時に実行できる、性能向上に大きく寄与する


## Q47
- 様々なページ置換法について学ぶ
    + 答え合わせ
    + https://en.wikipedia.org/wiki/Cache_replacement_policies


## Q48
- 4, 5番目のcolumnの意味
    + デバイス(major:minor)とその上のinodeの番号


## Q49 (FIXME)
- アソシエイティブキャッシュとはなにか、なぜTLBがそう呼ばれるのか
    + メインメモリのアドレスに一定の計算を行ってキャッシュメモリ上の格納位置を算出し、その位置にあるいくつかのブロックのいずれかにデータを格納する方式。
    + TLBではセットアソシアティブ方式を使用するから
- https://web.archive.org/web/20170508141002/https://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Memory/fully.html


## Q50
- 仮想メモリのregionとは
    + 以下の2つを満たすもの
    + ページサイズの倍数であるアドレスから始まる
    + すべてのページが同じパーミッションを持つ


# Q51
- プログラムの実行コードを、その実行中に書き換えようとしたらどうなる
    + segmentation failtでエラーになる


# Q52
- 無効なアドレスとは
    + ページの存在しないアドレス


# Q53
- 正規アドレスとは
    + 48から63ビット目が47ビット目と同じになっているアドレス


# Q54
- 変換テーブルとは
    + 仮想アドレスを物理アドレスに変換するための情報が格納されたデータ構造


# Q55
- ページフレームとは
    + ページと同じサイズを持つ物理メモリの領域


# Q56
- メモリの領域とは
    + メモリの連続した塊を指す


# Q57
- 仮想アドレス空間とはなにか、物理アドレス空間との違いは？
    + 仮想アドレス空間はページテーブルによって構築されるもの、プロセスごとに異なる
    + 物理アドレス空間は実際に搭載されたメモリの空間


# Q58
- TLBとはなにか
    + translation lookaside buffer.
    - 仮想メモリのためのキャッシュ機構

# Q59
- 仮想メモリ機構が十分に高速なのは何のおかげか？
    + 局所性とTLBのおかげ


# Q60
- アドレス空間はどうやって切り替えるのか
    + cr3レジスタの切り替え


# Q61
- 仮想メモリに組み込まれているプロテクション機構とは？
    + read, write, executionを有効無効に設定できる


# Q62
- EXBビットの目的は？
    + コード実行を禁止するためのフラグ


# Q63
- 仮想アドレスの構造は？
    + 4段構造、テーブルとそこに格納されるエントリからなる


# Q64
- 仮想アドレスと物理アドレスで共通する部分はあるのか？
    + 1バイト単位のアドレッシングであること


# Q65
- .textセクションに文字列を書けるか、それを読んだならどうなるか、上書きしたらどうなるか
    + コンパイル時であれば書き込める
    + それを読み出しは可能
    + 実行時に上書きは通常EXBビットで保護されるために不可能


# Q66
- システムコールのstat, open, mmapを呼び出すプログラムを書く
    + 066.nas


# Q67
- いろいろ
    + 067.nas
